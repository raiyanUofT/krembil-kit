"""
ConnectivityReader - Data Access for Connectivity Analysis Results
================================================================

This module provides data access capabilities for connectivity analysis results
generated by ConnectivityAnalyzer, enabling efficient extraction of adjacency
matrices and metadata from HDF5 and pickle files.
"""

import h5py
import numpy as np
import pickle
from pathlib import Path
from typing import Optional, List, Tuple, Union, Dict, Any


class ConnectivityReader:
    """
    Reader for ConnectivityAnalyzer results.
    
    Provides methods for loading connectivity analysis data from files created
    by ConnectivityAnalyzer, including correlation matrices, coherence matrices,
    and adjacency matrices from both pickle and HDF5 formats.
    """
    
    def __init__(self):
        """
        Initialize ConnectivityReader.
        
        No parameters required - all methods work with file paths provided at call time.
        """
        pass
    
    def load_correlation_matrices(self, file_path: Union[str, Path], 
                                time_range: Optional[Tuple[float, float]] = None) -> Dict[str, Any]:
        """
        Load correlation matrices from pickle or HDF5 file.
        
        Automatically detects file format and loads correlation data accordingly.
        
        Parameters
        ----------
        file_path : str or Path
            Path to pickle file (from compute_correlation) or HDF5 file (from generate_graphs)
        time_range : tuple of float, optional
            Time range as (start_seconds, end_seconds) to filter windows
        
        Returns
        -------
        dict
            Dictionary containing:
            - 'matrices': numpy array of correlation matrices, shape (n_windows, n_channels, n_channels)
            - 'window_times': numpy array of window start times in seconds
            - 'file_path': path to source file
            - 'source_format': 'pickle' or 'hdf5'
        
        Examples
        --------
        >>> reader = ConnectivityReader()
        >>> # Load from pickle file
        >>> data = reader.load_correlation_matrices("results/correlation/subject_correlation_0s-300s.pickle")
        >>> print(f"Loaded {data['matrices'].shape[0]} correlation matrices")
        >>> 
        >>> # Load from HDF5 file
        >>> data = reader.load_correlation_matrices("results/graphs/subject_graphs.h5")
        >>> correlation_matrices = data['matrices']
        >>> window_times = data['window_times']
        """
        file_path = Path(file_path)
        
        if not file_path.exists():
            raise FileNotFoundError(f"File not found: {file_path}")
        
        if file_path.suffix == '.pickle':
            return self._load_correlation_from_pickle(file_path, time_range)
        elif file_path.suffix == '.h5':
            return self._load_correlation_from_hdf5(file_path, time_range)
        else:
            raise ValueError(f"Unsupported file format: {file_path.suffix}. Expected .pickle or .h5")

    def load_coherence_matrices(self, file_path: Union[str, Path],
                              time_range: Optional[Tuple[float, float]] = None) -> Dict[str, Any]:
        """
        Load coherence matrices from pickle or HDF5 file.
        
        Automatically detects file format and loads coherence data accordingly.
        
        Parameters
        ----------
        file_path : str or Path
            Path to pickle file (from compute_coherence_average) or HDF5 file (from generate_graphs)
        time_range : tuple of float, optional
            Time range as (start_seconds, end_seconds) to filter windows
        
        Returns
        -------
        dict
            Dictionary containing:
            - 'matrices': numpy array of coherence matrices, shape (n_windows, n_channels, n_channels)
            - 'window_times': numpy array of window start times in seconds
            - 'file_path': path to source file
            - 'source_format': 'pickle' or 'hdf5'
        
        Examples
        --------
        >>> reader = ConnectivityReader()
        >>> # Load from pickle file
        >>> data = reader.load_coherence_matrices("results/coherence/average/subject_coherence_avg_0s-300s.pickle")
        >>> 
        >>> # Load from HDF5 file with time filtering
        >>> data = reader.load_coherence_matrices("results/graphs/subject_graphs.h5", time_range=(100, 200))
        >>> coherence_matrices = data['matrices']
        """
        file_path = Path(file_path)
        
        if not file_path.exists():
            raise FileNotFoundError(f"File not found: {file_path}")
        
        if file_path.suffix == '.pickle':
            return self._load_coherence_from_pickle(file_path, time_range)
        elif file_path.suffix == '.h5':
            return self._load_coherence_from_hdf5(file_path, time_range)
        else:
            raise ValueError(f"Unsupported file format: {file_path.suffix}. Expected .pickle or .h5")

    def load_coherence_by_frequency_bands(self, pickle_file_path: Union[str, Path],
                                         time_range: Optional[Tuple[float, float]] = None) -> Dict[str, Any]:
        """
        Load frequency-band specific coherence matrices from pickle file.
        
        This data is only available from pickle files created by compute_coherence_bands().
        
        Parameters
        ----------
        pickle_file_path : str or Path
            Path to pickle file from compute_coherence_bands()
        time_range : tuple of float, optional
            Time range as (start_seconds, end_seconds) to filter windows
        
        Returns
        -------
        dict
            Dictionary containing:
            - 'coherence_by_band': dict mapping frequency band names to matrices
            - 'frequency_bands': dict mapping band names to (low_freq, high_freq) tuples
            - 'window_times': numpy array of window start times in seconds
            - 'file_path': path to source file
        
        Examples
        --------
        >>> reader = ConnectivityReader()
        >>> data = reader.load_coherence_by_frequency_bands("results/coherence/bands/subject_coherence_bands_0s-300s.pickle")
        >>> alpha_coherence = data['coherence_by_band']['alpha']
        >>> beta_coherence = data['coherence_by_band']['beta']
        >>> print("Available bands:", list(data['coherence_by_band'].keys()))
        """
        file_path = Path(pickle_file_path)
        
        if not file_path.exists():
            raise FileNotFoundError(f"File not found: {file_path}")
        
        if file_path.suffix != '.pickle':
            raise ValueError(f"Expected .pickle file, got: {file_path.suffix}")
        
        with open(file_path, 'rb') as f:
            data = pickle.load(f)
        
        coherence_by_band = data['coherence_by_band']
        times = np.array(data['starts'])
        
        if time_range is not None:
            start_time, end_time = time_range
            time_mask = (times >= start_time) & (times <= end_time)
            
            filtered_bands = {}
            for band_name, matrices_list in coherence_by_band.items():
                if matrices_list:
                    matrices_array = np.array(matrices_list)
                    filtered_bands[band_name] = matrices_array[time_mask]
                else:
                    filtered_bands[band_name] = np.array([])
            
            coherence_by_band = filtered_bands
            times = times[time_mask]
        else:
            coherence_by_band = {band_name: np.array(matrices_list) 
                               for band_name, matrices_list in coherence_by_band.items()}
        
        return {
            'coherence_by_band': coherence_by_band,
            'frequency_bands': data['frequency_bands'],
            'window_times': times,
            'file_path': str(file_path)
        }

    def load_phase_matrices(self, hdf5_file_path: Union[str, Path],
                           time_range: Optional[Tuple[float, float]] = None) -> Dict[str, Any]:
        """
        Load phase matrices from HDF5 file.
        
        Phase matrices are only available from HDF5 files created by generate_graphs().
        
        Parameters
        ----------
        hdf5_file_path : str or Path
            Path to HDF5 file from generate_graphs()
        time_range : tuple of float, optional
            Time range as (start_seconds, end_seconds) to filter windows
        
        Returns
        -------
        dict
            Dictionary containing:
            - 'matrices': numpy array of phase matrices, shape (n_windows, n_channels, n_channels)
            - 'window_times': numpy array of window start times in seconds
            - 'file_path': path to source file
        
        Examples
        --------
        >>> reader = ConnectivityReader()
        >>> data = reader.load_phase_matrices("results/graphs/subject_graphs.h5")
        >>> phase_matrices = data['matrices']
        >>> window_times = data['window_times']
        """
        file_path = Path(hdf5_file_path)
        
        if not file_path.exists():
            raise FileNotFoundError(f"File not found: {file_path}")
        
        if file_path.suffix != '.h5':
            raise ValueError(f"Expected .h5 file, got: {file_path.suffix}")
        
        with h5py.File(file_path, 'r') as f:
            window_times = f['window_starts'][:]
            
            if time_range is not None:
                start_time, end_time = time_range
                time_mask = (window_times >= start_time) & (window_times <= end_time)
                phase_matrices = f['adjacency_matrices'][time_mask, 3, :, :]
                window_times = window_times[time_mask]
            else:
                phase_matrices = f['adjacency_matrices'][:, 3, :, :]
        
        return {
            'matrices': phase_matrices,
            'window_times': window_times,
            'file_path': str(file_path)
        }

    def load_adjacency_matrices(self, hdf5_file_path: Union[str, Path],
                              time_range: Optional[Tuple[float, float]] = None,
                              matrix_types: Optional[List[str]] = None) -> Dict[str, Any]:
        """
        Load adjacency matrices from HDF5 file.
        
        Loads all four adjacency matrix types: ones, correlation, coherence, and phase.
        
        Parameters
        ----------
        hdf5_file_path : str or Path
            Path to HDF5 file from generate_graphs()
        time_range : tuple of float, optional
            Time range as (start_seconds, end_seconds) to filter windows
        matrix_types : list of str, optional
            Matrix types to include: ['ones', 'correlation', 'coherence', 'phase'].
            If None, returns all matrix types.
        
        Returns
        -------
        dict
            Dictionary containing:
            - 'adjacency_matrices': numpy array, shape (n_windows, n_matrix_types, n_channels, n_channels)
            - 'matrix_type_names': list of matrix type names corresponding to the second dimension
            - 'window_times': numpy array of window start times in seconds
            - 'file_path': path to source file
        
        Matrix Types (second dimension indices):
            - Index 0: Ones matrix (fully connected baseline)
            - Index 1: Correlation matrix (Pearson correlation coefficients)
            - Index 2: Coherence matrix (frequency-averaged spectral connectivity)
            - Index 3: Phase matrix (phase-based coupling measures)
        
        Examples
        --------
        >>> reader = ConnectivityReader()
        >>> data = reader.load_adjacency_matrices("results/graphs/subject_graphs.h5")
        >>> adj_matrices = data['adjacency_matrices']
        >>> correlation_matrices = adj_matrices[:, 1, :, :]  # Extract correlation matrices
        >>> 
        >>> # Load specific matrix types
        >>> data = reader.load_adjacency_matrices("results/graphs/subject_graphs.h5", 
        ...                                      matrix_types=['correlation', 'coherence'])
        >>> print(data['matrix_type_names'])  # ['correlation', 'coherence']
        """
        file_path = Path(hdf5_file_path)
        
        if not file_path.exists():
            raise FileNotFoundError(f"File not found: {file_path}")
        
        if file_path.suffix != '.h5':
            raise ValueError(f"Expected .h5 file, got: {file_path.suffix}")
        
        with h5py.File(file_path, 'r') as f:
            window_times = f['window_starts'][:]
            
            type_mapping = {'ones': 0, 'correlation': 1, 'coherence': 2, 'phase': 3}
            all_type_names = ['ones', 'correlation', 'coherence', 'phase']
            
            if matrix_types is not None:
                valid_types = [t for t in matrix_types if t in type_mapping]
                if len(valid_types) != len(matrix_types):
                    invalid_types = set(matrix_types) - set(valid_types)
                    raise ValueError(f"Invalid matrix types: {invalid_types}. Valid types: {list(type_mapping.keys())}")
                
                type_indices = [type_mapping[t] for t in valid_types]
                matrix_type_names = valid_types
            else:
                type_indices = [0, 1, 2, 3]
                matrix_type_names = all_type_names
            
            if time_range is not None:
                start_time, end_time = time_range
                time_mask = (window_times >= start_time) & (window_times <= end_time)
                adj_matrices = f['adjacency_matrices'][time_mask][:, type_indices, :, :]
                window_times = window_times[time_mask]
            else:
                adj_matrices = f['adjacency_matrices'][:, type_indices, :, :]
        
        return {
            'adjacency_matrices': adj_matrices,
            'matrix_type_names': matrix_type_names,
            'window_times': window_times,
            'file_path': str(file_path)
        }

    def load_graph_features(self, hdf5_file_path: Union[str, Path],
                           time_range: Optional[Tuple[float, float]] = None) -> Dict[str, Any]:
        """
        Load complete graph data including adjacency matrices and node/edge features from HDF5 file.
        
        Parameters
        ----------
        hdf5_file_path : str or Path
            Path to HDF5 file from generate_graphs()
        time_range : tuple of float, optional
            Time range as (start_seconds, end_seconds) to filter windows
        
        Returns
        -------
        dict
            Dictionary containing:
            - 'adjacency_matrices': numpy array, shape (n_windows, 4, n_channels, n_channels)
            - 'node_features': list of node feature arrays (if available)
            - 'edge_features': list of edge feature arrays (if available)
            - 'window_times': numpy array of window start times in seconds
            - 'metadata': dict of analysis metadata from HDF5 attributes
            - 'file_path': path to source file
            - 'has_node_features': bool indicating if node features are present
            - 'has_edge_features': bool indicating if edge features are present
        
        Examples
        --------
        >>> reader = ConnectivityReader()
        >>> data = reader.load_graph_features("results/graphs/subject_graphs.h5")
        >>> adj_matrices = data['adjacency_matrices']
        >>> if data['has_node_features']:
        ...     node_features = data['node_features']
        >>> print(f"Loaded {len(data['window_times'])} time windows")
        """
        file_path = Path(hdf5_file_path)
        
        if not file_path.exists():
            raise FileNotFoundError(f"File not found: {file_path}")
        
        if file_path.suffix != '.h5':
            raise ValueError(f"Expected .h5 file, got: {file_path.suffix}")
        
        with h5py.File(file_path, 'r') as f:
            window_times = f['window_starts'][:]
            
            if time_range is not None:
                start_time, end_time = time_range
                time_mask = (window_times >= start_time) & (window_times <= end_time)
                adj_matrices = f['adjacency_matrices'][time_mask]
                window_times = window_times[time_mask]
                time_indices = np.where(time_mask)[0]
            else:
                adj_matrices = f['adjacency_matrices'][:]
                time_indices = None
            
            # Load node features if available
            has_node_features = 'node_features' in f
            node_features = None
            if has_node_features:
                if time_indices is not None:
                    node_features = [f['node_features'][i] for i in time_indices]
                else:
                    node_features = [f['node_features'][i] for i in range(len(f['node_features']))]
            
            # Load edge features if available
            has_edge_features = 'edge_features' in f
            edge_features = None
            if has_edge_features:
                if time_indices is not None:
                    edge_features = [f['edge_features'][i] for i in time_indices]
                else:
                    edge_features = [f['edge_features'][i] for i in range(len(f['edge_features']))]
            
            # Load metadata
            metadata = dict(f.attrs)
        
        return {
            'adjacency_matrices': adj_matrices,
            'node_features': node_features,
            'edge_features': edge_features,
            'window_times': window_times,
            'metadata': metadata,
            'file_path': str(file_path),
            'has_node_features': has_node_features,
            'has_edge_features': has_edge_features
        }

    # Private helper methods
    def _load_correlation_from_pickle(self, file_path: Path, time_range: Optional[Tuple[float, float]]) -> Dict[str, Any]:
        """Load correlation data from pickle file."""
        with open(file_path, 'rb') as f:
            data = pickle.load(f)
        
        matrices = np.array(data['corr_matrices'])
        times = np.array(data['starts'])
        
        if time_range is not None:
            start_time, end_time = time_range
            time_mask = (times >= start_time) & (times <= end_time)
            matrices = matrices[time_mask]
            times = times[time_mask]
        
        return {
            'matrices': matrices,
            'window_times': times,
            'file_path': str(file_path),
            'source_format': 'pickle'
        }

    def _load_correlation_from_hdf5(self, file_path: Path, time_range: Optional[Tuple[float, float]]) -> Dict[str, Any]:
        """Load correlation data from HDF5 file."""
        with h5py.File(file_path, 'r') as f:
            window_times = f['window_starts'][:]
            
            if time_range is not None:
                start_time, end_time = time_range
                time_mask = (window_times >= start_time) & (window_times <= end_time)
                correlation_matrices = f['adjacency_matrices'][time_mask, 1, :, :]
                window_times = window_times[time_mask]
            else:
                correlation_matrices = f['adjacency_matrices'][:, 1, :, :]
        
        return {
            'matrices': correlation_matrices,
            'window_times': window_times,
            'file_path': str(file_path),
            'source_format': 'hdf5'
        }

    def _load_coherence_from_pickle(self, file_path: Path, time_range: Optional[Tuple[float, float]]) -> Dict[str, Any]:
        """Load coherence data from pickle file."""
        with open(file_path, 'rb') as f:
            data = pickle.load(f)
        
        matrices = np.array(data['coherence_matrices'])
        times = np.array(data['starts'])
        
        if time_range is not None:
            start_time, end_time = time_range
            time_mask = (times >= start_time) & (times <= end_time)
            matrices = matrices[time_mask]
            times = times[time_mask]
        
        return {
            'matrices': matrices,
            'window_times': times,
            'file_path': str(file_path),
            'source_format': 'pickle'
        }

    def _load_coherence_from_hdf5(self, file_path: Path, time_range: Optional[Tuple[float, float]]) -> Dict[str, Any]:
        """Load coherence data from HDF5 file."""
        with h5py.File(file_path, 'r') as f:
            window_times = f['window_starts'][:]
            
            if time_range is not None:
                start_time, end_time = time_range
                time_mask = (window_times >= start_time) & (window_times <= end_time)
                coherence_matrices = f['adjacency_matrices'][time_mask, 2, :, :]
                window_times = window_times[time_mask]
            else:
                coherence_matrices = f['adjacency_matrices'][:, 2, :, :]
        
        return {
            'matrices': coherence_matrices,
            'window_times': window_times,
            'file_path': str(file_path),
            'source_format': 'hdf5'
        }